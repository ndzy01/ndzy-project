import{a as Ct,r as R}from"./vendor_react-xEkgX5Pu.js";import{s as Qt}from"./vendor_use-sync-external-store-MHW6hckK.js";const U=()=>{},v=U(),it=Object,a=t=>t===v,F=t=>typeof t=="function",P=(t,e)=>({...t,...e}),Zt=t=>F(t.then),ot=new WeakMap;let te=0;const Z=t=>{const e=typeof t,n=t&&t.constructor,o=n==Date;let s,i;if(it(t)===t&&!o&&n!=RegExp){if(s=ot.get(t),s)return s;if(s=++te+"~",ot.set(t,s),n==Array){for(s="@",i=0;i<t.length;i++)s+=Z(t[i])+",";ot.set(t,s)}if(n==it){s="#";const c=it.keys(t).sort();for(;!a(i=c.pop());)a(t[i])||(s+=i+":"+Z(t[i])+",");ot.set(t,s)}}else s=o?t.toJSON():e=="symbol"?t.toString():e=="string"?JSON.stringify(t):""+t;return s},M=new WeakMap,ft={},rt={},pt="undefined",ct=typeof window!=pt,Rt=typeof document!=pt,ee=()=>ct&&typeof window.requestAnimationFrame!=pt,Pt=(t,e)=>{const n=M.get(t);return[()=>!a(e)&&t.get(e)||ft,o=>{if(!a(e)){const s=t.get(e);e in rt||(rt[e]=s),n[5](e,P(s,o),s||ft)}},n[6],()=>!a(e)&&e in rt?rt[e]:!a(e)&&t.get(e)||ft]};let ht=!0;const ne=()=>ht,[_t,Tt]=ct&&window.addEventListener?[window.addEventListener.bind(window),window.removeEventListener.bind(window)]:[U,U],se=()=>{const t=Rt&&document.visibilityState;return a(t)||t!=="hidden"},oe=t=>(Rt&&document.addEventListener("visibilitychange",t),_t("focus",t),()=>{Rt&&document.removeEventListener("visibilitychange",t),Tt("focus",t)}),re=t=>{const e=()=>{ht=!0,t()},n=()=>{ht=!1};return _t("online",e),_t("offline",n),()=>{Tt("online",e),Tt("offline",n)}},ie={isOnline:ne,isVisible:se},ae={initFocus:oe,initReconnect:re},Ft=!Ct.useId,tt=!ct||"Deno"in window,ce=t=>ee()?window.requestAnimationFrame(t):setTimeout(t,1),at=tt?R.useEffect:R.useLayoutEffect,dt=typeof navigator<"u"&&navigator.connection,xt=!tt&&dt&&(["slow-2g","2g"].includes(dt.effectiveType)||dt.saveData),wt=t=>{if(F(t))try{t=t()}catch{t=""}const e=t;return t=typeof t=="string"?t:(Array.isArray(t)?t.length:t)?Z(t):"",[t,e]};let ue=0;const gt=()=>++ue,Ut=0,qt=1,Ht=2,le=3;var Q={__proto__:null,ERROR_REVALIDATE_EVENT:le,FOCUS_EVENT:Ut,MUTATE_EVENT:Ht,RECONNECT_EVENT:qt};async function $t(...t){const[e,n,o,s]=t,i=P({populateCache:!0,throwOnError:!0},typeof s=="boolean"?{revalidate:s}:s||{});let c=i.populateCache;const d=i.rollbackOnError;let u=i.optimisticData;const V=i.revalidate!==!1,T=D=>typeof d=="function"?d(D):d!==!1,g=i.throwOnError;if(F(n)){const D=n,C=[],O=e.keys();for(const L of O)!/^\$(inf|sub)\$/.test(L)&&D(e.get(L)._k)&&C.push(L);return Promise.all(C.map(I))}return I(n);async function I(D){const[C]=wt(D);if(!C)return;const[O,L]=Pt(e,C),[r,j,Y,q]=M.get(e),H=()=>{const w=r[C];return V&&(delete Y[C],delete q[C],w&&w[0])?w[0](Ht).then(()=>O().data):O().data};if(t.length<3)return H();let p=o,b;const h=gt();j[C]=[h,0];const k=!a(u),N=O(),z=N.data,et=N._c,$=a(et)?z:et;if(k&&(u=F(u)?u($,z):u,L({data:u,_c:$})),F(p))try{p=p($)}catch(w){b=w}if(p&&Zt(p))if(p=await p.catch(w=>{b=w}),h!==j[C][0]){if(b)throw b;return p}else b&&k&&T(b)&&(c=!0,L({data:$,_c:v}));if(c&&!b)if(F(c)){const w=c(p,$);L({data:w,error:v,_c:v})}else L({data:p,error:v,_c:v});if(j[C][1]=gt(),Promise.resolve(H()).then(()=>{L({_c:v})}),b){if(g)throw b;return}return p}}const Wt=(t,e)=>{for(const n in t)t[n][0]&&t[n][0](e)},jt=(t,e)=>{if(!M.has(t)){const n=P(ae,e),o={},s=$t.bind(v,t);let i=U;const c={},d=(T,g)=>{const I=c[T]||[];return c[T]=I,I.push(g),()=>I.splice(I.indexOf(g),1)},u=(T,g,I)=>{t.set(T,g);const D=c[T];if(D)for(const C of D)C(g,I)},V=()=>{if(!M.has(t)&&(M.set(t,[o,{},{},{},s,u,d]),!tt)){const T=n.initFocus(setTimeout.bind(v,Wt.bind(v,o,Ut))),g=n.initReconnect(setTimeout.bind(v,Wt.bind(v,o,qt)));i=()=>{T&&T(),g&&g(),M.delete(t)}}};return V(),[t,s,V,i]}return[t,M.get(t)[4]]},fe=(t,e,n,o,s)=>{const i=n.errorRetryCount,c=s.retryCount,d=~~((Math.random()+.5)*(1<<(c<8?c:8)))*n.errorRetryInterval;!a(i)&&c>i||setTimeout(o,d,s)},de=(t,e)=>Z(t)==Z(e),[St,Ee]=jt(new Map),kt=P({onLoadingSlow:U,onSuccess:U,onError:U,onErrorRetry:fe,onDiscarded:U,revalidateOnFocus:!0,revalidateOnReconnect:!0,revalidateIfStale:!0,shouldRetryOnError:!0,errorRetryInterval:xt?1e4:5e3,focusThrottleInterval:5*1e3,dedupingInterval:2*1e3,loadingTimeout:xt?5e3:3e3,compare:de,isPaused:()=>!1,cache:St,mutate:Ee,fallback:{}},ie),zt=(t,e)=>{const n=P(t,e);if(e){const{use:o,fallback:s}=t,{use:i,fallback:c}=e;o&&i&&(n.use=o.concat(i)),s&&c&&(n.fallback=P(s,c))}return n},mt=R.createContext({}),Re=t=>{const{value:e}=t,n=R.useContext(mt),o=F(e),s=R.useMemo(()=>o?e(n):e,[o,n,e]),i=R.useMemo(()=>o?s:zt(n,s),[o,n,s]),c=s&&s.provider,d=R.useRef(v);c&&!d.current&&(d.current=jt(c(i.cache||St),s));const u=d.current;return u&&(i.cache=u[0],i.mutate=u[1]),at(()=>{if(u)return u[2]&&u[2](),u[3]},[]),R.createElement(mt.Provider,P(t,{value:i}))},he="$inf$",Bt=ct&&window.__SWR_DEVTOOLS_USE__,_e=Bt?window.__SWR_DEVTOOLS_USE__:[],Te=()=>{Bt&&(window.__SWR_DEVTOOLS_REACT__=Ct)},ge=t=>F(t[1])?[t[0],t[1],t[2]||{}]:[t[0],null,(t[1]===null?t[2]:t[1])||{}],me=()=>P(kt,R.useContext(mt)),Ce=t=>(e,n,o)=>t(e,n&&((...i)=>{const[c]=wt(e),[,,,d]=M.get(St);if(c.startsWith(he))return n(...i);const u=d[c];return a(u)?n(...i):(delete d[c],u)}),o),pe=_e.concat(Ce),we=t=>function(...n){const o=me(),[s,i,c]=ge(n),d=zt(o,c);let u=t;const{use:V}=d,T=(V||[]).concat(pe);for(let g=T.length;g--;)u=T[g](u);return u(s,i||d.fetcher||null,d)},Se=(t,e,n)=>{const o=e[t]||(e[t]=[]);return o.push(n),()=>{const s=o.indexOf(n);s>=0&&(o[s]=o[o.length-1],o.pop())}};Te();const Mt=Ct.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(e=>{t.status="fulfilled",t.value=e},e=>{t.status="rejected",t.reason=e}),t)}),Et={dedupe:!0},ve=(t,e,n)=>{const{cache:o,compare:s,suspense:i,fallbackData:c,revalidateOnMount:d,revalidateIfStale:u,refreshInterval:V,refreshWhenHidden:T,refreshWhenOffline:g,keepPreviousData:I}=n,[D,C,O,L]=M.get(o),[r,j]=wt(t),Y=R.useRef(!1),q=R.useRef(!1),H=R.useRef(r),p=R.useRef(e),b=R.useRef(n),h=()=>b.current,k=()=>h().isVisible()&&h().isOnline(),[N,z,et,$]=Pt(o,r),w=R.useRef({}).current,Jt=a(c)?n.fallback[r]:c,vt=(l,f)=>{for(const m in w){const E=m;if(E==="data"){if(!s(l[E],f[E])&&(!a(l[E])||!s(st,f[E])))return!1}else if(f[E]!==l[E])return!1}return!0},Dt=R.useMemo(()=>{const l=!r||!e?!1:a(d)?h().isPaused()||i?!1:a(u)?!0:u:d,f=S=>{const x=P(S);return delete x._k,l?{isValidating:!0,isLoading:!0,...x}:x},m=N(),E=$(),y=f(m),G=m===E?y:f(E);let _=y;return[()=>{const S=f(N());return vt(S,_)?(_.data=S.data,_.isLoading=S.isLoading,_.isValidating=S.isValidating,_.error=S.error,_):(_=S,S)},()=>G]},[o,r]),B=Qt.useSyncExternalStore(R.useCallback(l=>et(r,(f,m)=>{vt(m,f)||l()}),[o,r]),Dt[0],Dt[1]),Ot=!Y.current,Kt=D[r]&&D[r].length>0,J=B.data,K=a(J)?Jt:J,nt=B.error,bt=R.useRef(K),st=I?a(J)?bt.current:J:K,At=Kt&&!a(nt)?!1:Ot&&!a(d)?d:h().isPaused()?!1:i?a(K)?!1:u:a(K)||u,Vt=!!(r&&e&&Ot&&At),Gt=a(B.isValidating)?Vt:B.isValidating,Yt=a(B.isLoading)?Vt:B.isLoading,X=R.useCallback(async l=>{const f=p.current;if(!r||!f||q.current||h().isPaused())return!1;let m,E,y=!0;const G=l||{},_=!O[r]||!G.dedupe,S=()=>Ft?!q.current&&r===H.current&&Y.current:r===H.current,x={isValidating:!1,isLoading:!1},Lt=()=>{z(x)},Nt=()=>{const A=O[r];A&&A[1]===E&&delete O[r]},yt={isValidating:!0};a(N().data)&&(yt.isLoading=!0);try{if(_&&(z(yt),n.loadingTimeout&&a(N().data)&&setTimeout(()=>{y&&S()&&h().onLoadingSlow(r,n)},n.loadingTimeout),O[r]=[f(j),gt()]),[m,E]=O[r],m=await m,_&&setTimeout(Nt,n.dedupingInterval),!O[r]||O[r][1]!==E)return _&&S()&&h().onDiscarded(r),!1;x.error=v;const A=C[r];if(!a(A)&&(E<=A[0]||E<=A[1]||A[1]===0))return Lt(),_&&S()&&h().onDiscarded(r),!1;const W=N().data;x.data=s(W,m)?W:m,_&&S()&&h().onSuccess(m,r,n)}catch(A){Nt();const W=h(),{shouldRetryOnError:ut}=W;W.isPaused()||(x.error=A,_&&S()&&(W.onError(A,r,W),(ut===!0||F(ut)&&ut(A))&&k()&&W.onErrorRetry(A,r,W,Xt=>{const lt=D[r];lt&&lt[0]&&lt[0](Q.ERROR_REVALIDATE_EVENT,Xt)},{retryCount:(G.retryCount||0)+1,dedupe:!0})))}return y=!1,Lt(),!0},[r,o]),It=R.useCallback((...l)=>$t(o,H.current,...l),[]);if(at(()=>{p.current=e,b.current=n,a(J)||(bt.current=J)}),at(()=>{if(!r)return;const l=X.bind(v,Et);let f=0;const E=Se(r,D,(y,G={})=>{if(y==Q.FOCUS_EVENT){const _=Date.now();h().revalidateOnFocus&&_>f&&k()&&(f=_+h().focusThrottleInterval,l())}else if(y==Q.RECONNECT_EVENT)h().revalidateOnReconnect&&k()&&l();else{if(y==Q.MUTATE_EVENT)return X();if(y==Q.ERROR_REVALIDATE_EVENT)return X(G)}});return q.current=!1,H.current=r,Y.current=!0,z({_k:j}),At&&(a(K)||tt?l():ce(l)),()=>{q.current=!0,E()}},[r]),at(()=>{let l;function f(){const E=F(V)?V(N().data):V;E&&l!==-1&&(l=setTimeout(m,E))}function m(){!N().error&&(T||h().isVisible())&&(g||h().isOnline())?X(Et).then(f):f()}return f(),()=>{l&&(clearTimeout(l),l=-1)}},[V,T,g,r]),R.useDebugValue(st),i&&a(K)&&r){if(!Ft&&tt)throw new Error("Fallback data is required when using suspense in SSR.");p.current=e,b.current=n,q.current=!1;const l=L[r];if(!a(l)){const f=It(l);Mt(f)}if(a(nt)){const f=X(Et);a(st)||(f.status="fulfilled",f.value=!0),Mt(f)}else throw nt}return{mutate:It,get data(){return w.data=!0,st},get error(){return w.error=!0,nt},get isValidating(){return w.isValidating=!0,Gt},get isLoading(){return w.isLoading=!0,Yt}}},be=it.defineProperty(Re,"defaultValue",{value:kt}),Ae=we(ve);export{be as S,Ae as a,me as u};
